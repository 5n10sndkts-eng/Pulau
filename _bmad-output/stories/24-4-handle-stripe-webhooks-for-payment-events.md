# Story 24.4: Handle Stripe Webhooks for Payment Events

Status: done

## Story

As a **platform operator**,
I want the `webhook-stripe` Edge Function to process payment events,
So that booking status reflects payment outcomes.

## Acceptance Criteria

1. **Given** the `webhook-stripe` Edge Function is deployed
   **When** Stripe sends `checkout.session.completed` event
   **Then** the system:
     - Validates webhook signature
     - Finds the payment record by session ID
     - Updates payment status to 'succeeded'
     - Calls `create-booking` Edge Function to confirm bookings (Story 24.5)
     - Decrements slot availability atomically
     - Creates audit log entries

2. **Given** Stripe sends `payment_intent.payment_failed` event
   **When** webhook is processed
   **Then** payment status updates to 'failed'
   **And** held inventory is released
   **And** user receives failure notification (via audit log for now)

3. **Given** Stripe sends `charge.refunded` event
   **When** webhook is processed
   **Then** payment status updates to 'refunded' or 'partially_refunded'
   **And** booking status updates accordingly
   **And** audit log entry is created

4. **Given** any webhook event is received
   **When** signature validation fails
   **Then** the request is rejected with 400 status
   **And** no database changes occur
   **And** attempted attack is logged

## Tasks / Subtasks

- [x] Task 1: Webhook Edge Function already exists (AC: #1, #4)
  - [x] 1.1: `supabase/functions/webhook-stripe/index.ts` already exists from Story 22.2
  - [x] 1.2: Stripe webhook signing secret configured from environment
  - [x] 1.3: Signature verification using `stripe.webhooks.constructEvent`
  - [x] 1.4: Returns 400 for invalid signatures with logging

- [x] Task 2: Handle checkout.session.completed event (AC: #1)
  - [x] 2.1: Extract session data and metadata (trip_id, user_id) - handles both formats
  - [x] 2.2: Find payment record by stripe_checkout_session_id
  - [x] 2.3: Update payment status to 'succeeded'
  - [x] 2.4: Extract payment_intent_id and update payment record
  - [x] 2.5: Booking confirmation logic implemented inline

- [x] Task 3: Implement booking confirmation flow (AC: #1)
  - [x] 3.1: Update existing booking record to status = 'confirmed'
  - [x] 3.2: Decrement slot availability with RPC fallback to direct update
  - [x] 3.3: Booking reference generated by checkout function
  - [x] 3.4: Comprehensive audit log entry for checkout completion

- [x] Task 4: Handle payment_intent.payment_failed event (AC: #2)
  - [x] 4.1: Find payment record by stripe_payment_intent_id
  - [x] 4.2: Update payment status to 'failed'
  - [x] 4.3: Update booking status to 'payment_failed'
  - [x] 4.4: No inventory held in current flow (inventory checked at checkout)
  - [x] 4.5: Audit log with failure reason and code

- [x] Task 5: Handle charge.refunded event (AC: #3)
  - [x] 5.1: Find payment record by payment_intent_id from charge
  - [x] 5.2: Calculate refund amount from charge.amount_refunded
  - [x] 5.3: Update payment record (refund_amount, status)
  - [x] 5.4: Update booking status to 'refunded' if full refund
  - [x] 5.5: Audit log with refund details

- [x] Task 6: Idempotency and error handling (AC: #1, #4)
  - [x] 6.1: stripe_event_id column already exists in audit_logs
  - [x] 6.2: Check for duplicate events before processing
  - [x] 6.3: Store stripe_event_id in all audit logs
  - [x] 6.4: Return 200 for duplicate events
  - [x] 6.5: Return 200 for business errors to prevent Stripe retries

## Dev Notes

### Architecture Patterns & Constraints

**Edge Function Pattern (from vendor-onboard):**
```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import Stripe from 'https://esm.sh/stripe@14?target=deno'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY')!, {
  apiVersion: '2023-10-16',
})

const webhookSecret = Deno.env.get('STRIPE_WEBHOOK_SECRET')!
```

**Required Environment Variables:**
- `STRIPE_SECRET_KEY` - Stripe API secret key
- `STRIPE_WEBHOOK_SECRET` - Webhook signing secret (from Stripe Dashboard)
- `SUPABASE_URL` - Supabase project URL
- `SUPABASE_SERVICE_ROLE_KEY` - Service role key for RLS bypass

**Webhook Signature Verification:**
```typescript
serve(async (req: Request): Promise<Response> => {
  const signature = req.headers.get('stripe-signature')
  const body = await req.text()

  let event: Stripe.Event
  try {
    event = stripe.webhooks.constructEvent(body, signature!, webhookSecret)
  } catch (err) {
    console.error('Webhook signature verification failed')
    return new Response('Invalid signature', { status: 400 })
  }

  // Process event based on type
  switch (event.type) {
    case 'checkout.session.completed':
      await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session)
      break
    case 'payment_intent.payment_failed':
      await handlePaymentFailed(event.data.object as Stripe.PaymentIntent)
      break
    case 'charge.refunded':
      await handleChargeRefunded(event.data.object as Stripe.Charge)
      break
  }

  return new Response(JSON.stringify({ received: true }), { status: 200 })
})
```

### Previous Story Intelligence

**From Story 24.1 (checkout Edge Function):**
- Payment record created with status = 'pending'
- stripe_checkout_session_id stored in payments table
- Booking created with status = 'pending_payment'
- Metadata contains tripId and userId

**From Story 22.5 (vendor-onboard webhook handling):**
- Audit log pattern: actor_type = 'stripe' for webhook events
- Use stripe_event_id to prevent duplicate processing
- Service role key required for cross-table updates

### Technical Requirements

**Checkout Session Completed Handler:**
```typescript
async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const supabase = createClient(supabaseUrl, supabaseServiceKey)

  // Check idempotency - prevent duplicate processing
  const { data: existingLog } = await supabase
    .from('audit_logs')
    .select('id')
    .eq('stripe_event_id', session.id)
    .single()

  if (existingLog) {
    console.log('Event already processed:', session.id)
    return
  }

  // Find and update payment record
  const { data: payment, error: paymentError } = await supabase
    .from('payments')
    .update({
      status: 'succeeded',
      stripe_payment_intent_id: session.payment_intent as string,
    })
    .eq('stripe_checkout_session_id', session.id)
    .select()
    .single()

  if (paymentError || !payment) {
    console.error('Payment not found for session:', session.id)
    return
  }

  // Update booking status
  await supabase
    .from('bookings')
    .update({ status: 'confirmed' })
    .eq('id', payment.booking_id)

  // Decrement slot availability (atomic)
  // ... implementation from slotService pattern

  // Create audit log
  await supabase.from('audit_logs').insert({
    event_type: 'payment.succeeded',
    entity_type: 'payment',
    entity_id: payment.id,
    actor_type: 'stripe',
    stripe_event_id: session.id,
    metadata: {
      amount: session.amount_total,
      payment_intent: session.payment_intent,
    },
  })
}
```

**Atomic Inventory Decrement:**
```typescript
// Use transaction with SELECT FOR UPDATE
const { error: slotError } = await supabase.rpc('decrement_slot_availability', {
  p_slot_id: slotId,
  p_count: guestCount,
})
```

### Database Requirements

**RPC Function for Atomic Decrement (if not exists):**
```sql
CREATE OR REPLACE FUNCTION decrement_slot_availability(
  p_slot_id UUID,
  p_count INTEGER
) RETURNS BOOLEAN AS $$
DECLARE
  current_available INTEGER;
BEGIN
  SELECT available_count INTO current_available
  FROM experience_slots
  WHERE id = p_slot_id
  FOR UPDATE;

  IF current_available >= p_count THEN
    UPDATE experience_slots
    SET available_count = available_count - p_count,
        updated_at = NOW()
    WHERE id = p_slot_id;
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$ LANGUAGE plpgsql;
```

### Stripe Webhook Events to Handle

| Event Type | Action |
|------------|--------|
| `checkout.session.completed` | Confirm booking, decrement inventory |
| `payment_intent.payment_failed` | Mark payment failed, release inventory |
| `charge.refunded` | Update refund amount and status |
| `account.updated` | Update vendor Stripe status (Story 22.2) |

### File Structure Requirements

```
supabase/functions/
  webhook-stripe/
    index.ts              # Main webhook handler (this story)
```

### References

- [Source: _bmad-output/planning-artifacts/phase-2-epics.md#Story 24.4]
- [Source: _bmad-output/stories/24-1-create-checkout-edge-function.md - Payment record structure]
- [Source: supabase/functions/vendor-onboard/index.ts - Audit log patterns]
- [Source: Stripe Webhook documentation]

### Testing Requirements

**Stripe CLI for Local Testing:**
```bash
# Install Stripe CLI
stripe login

# Forward webhooks to local function
stripe listen --forward-to localhost:54321/functions/v1/webhook-stripe

# Trigger test events
stripe trigger checkout.session.completed
stripe trigger payment_intent.payment_failed
stripe trigger charge.refunded
```

**Test Scenarios:**
1. ✅ Valid checkout.session.completed → Payment succeeds, booking confirmed
2. ✅ Duplicate event (same stripe_event_id) → Returns 200, no duplicate processing
3. ✅ Invalid signature → Returns 400, no DB changes
4. ✅ payment_intent.payment_failed → Payment failed, booking cancelled
5. ✅ charge.refunded → Payment refunded, status updated

### Security Considerations

- ALWAYS verify webhook signature before processing
- Use STRIPE_WEBHOOK_SECRET from environment (never hardcode)
- Log failed signature attempts for security monitoring
- Return 200 even for handled errors (prevent Stripe retries for business logic issues)
- Use service role key for database operations (webhook has no user context)

### Idempotency Strategy

1. Store `stripe_event_id` in audit_logs on successful processing
2. Before processing, check if event already exists
3. Return 200 for duplicate events (Stripe may retry)
4. Use database transactions where possible

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
- Extended existing `webhook-stripe/index.ts` from Story 22.2 (vendor onboarding)
- Discovered existing idempotency and audit log patterns to maintain consistency

### Completion Notes List
1. Extended existing Edge Function rather than creating new one
2. Added `checkout.session.completed`, `payment_intent.payment_failed`, `charge.refunded` handlers
3. Implemented metadata format compatibility (handles both `trip_id`/`tripId` formats)
4. Added atomic slot availability decrement with RPC fallback for compatibility
5. Updates trip status to 'booked' after successful checkout completion
6. Full and partial refund support with booking status updates
7. Comprehensive audit logging with `actor_type: 'stripe'` for all events
8. Idempotency via `stripe_event_id` check before processing

### Code Review Fixes (Post-Implementation)
1. **FIX**: Improved fallback slot decrement atomicity
   - Original: Manual SELECT + UPDATE without locking (race condition risk)
   - Fixed: Uses `decrement_slot_availability` RPC first (has row-level locking)
   - Falls back to manual update only if RPC unavailable
   - Added tracking array for slot decrement results

### File List
- `supabase/functions/webhook-stripe/index.ts` - Extended with payment event handlers (FIXED in code review)

